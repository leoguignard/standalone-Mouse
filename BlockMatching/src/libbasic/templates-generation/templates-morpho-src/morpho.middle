/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) _TEST_ (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) _TEST_ (RES) ) RES = (A)
*/

/* 
   _NOTHINGTOBEDONE_
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   BOG_ -> [Binary | GreyLevel ]
           in case of Binary    => _BINARY_OPERATION_ == 1
	   in case of GreyLevel => _BINARY_OPERATION_ == 0
   OPERATION -> [Erosion | Dilation]
           in case of Erosion  => _TEST_ == '<'
	                          _INTOP_ == '&'
	   in case of Dilation => _TEST_ == '>'
	                          _INTOP_ == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void BOG_OPERATION_TYPE ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  char *proc = "BOG_OPERATION_TYPE";
  int conn = 0;                 /* "local" connectivity */
  TYPE *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(TYPE);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)vtmalloc( (unsigned int)(5 * auxIntSize * sizeof(int)), "localBuf", proc );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register TYPE *cur = (TYPE*)(input);
	TYPE *resBuf = (TYPE*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register TYPE *px = cur, *nx = cur, *py = cur, *ny = cur;
	register TYPE *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (TYPE*)auxCurr;
	  /* first row */
	  *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if _BINARY_OPERATION_
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if _BINARY_OPERATION_
	      if ( *cur == _NOTHINGTOBEDONE_ ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if _BINARY_OPERATION_
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register TYPE *cur = (TYPE*)(input);
	TYPE *resBuf = (TYPE*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register TYPE *px = cur;
	register TYPE *cy, *py, *ny;
	register TYPE *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (TYPE*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	      if ( *cur == _NOTHINGTOBEDONE_ ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (TYPE*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if _BINARY_OPERATION_
	    if ( *cy == _NOTHINGTOBEDONE_ ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) _TEST_ (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register TYPE *cur = (TYPE*)(input);
	TYPE *resBuf = (TYPE*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register TYPE *px = cur, *nx = cur, *py = cur, *ny = cur;
	register TYPE *pz = cur, *nz = cur; 
	register TYPE *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (TYPE*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (TYPE*)auxCurr;
	  /* middle slice, first row */
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if _BINARY_OPERATION_
	      if ( *cur == _NOTHINGTOBEDONE_ ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (TYPE*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) _TEST_ (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) _TEST_ (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if _BINARY_OPERATION_
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cur == _NOTHINGTOBEDONE_ ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) _TEST_ (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) _TEST_ (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register TYPE *cur = (TYPE*)(input);
	TYPE *resBuf = (TYPE*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register TYPE *px = cur;
	register TYPE *cy, *py, *ny;
#if _BINARY_OPERATION_
	register int *ires, *ic, *in, *ip;
#else
	register TYPE *cz, *pz, *nz;
#endif
	register TYPE *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (TYPE*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (TYPE*)auxCurr;
	py = cy = ny = (TYPE*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cy == _NOTHINGTOBEDONE_ ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (TYPE*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (TYPE*)auxNext;
	py = cy = ny = (TYPE*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cy == _NOTHINGTOBEDONE_ ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if _BINARY_OPERATION_
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ _INTOP_ *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (TYPE*)auxCurr;   nz = (TYPE*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) _TEST_ (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (TYPE*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	      if ( *cur == _NOTHINGTOBEDONE_ ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (TYPE*)auxNext;
	  py = cy = ny = (TYPE*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cy == _NOTHINGTOBEDONE_ ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if _BINARY_OPERATION_
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ _INTOP_ *in++ _INTOP_ *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (TYPE*)auxPrev;   cz = (TYPE*)auxCurr;
	  nz = (TYPE*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) _TEST_ (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) _TEST_ (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if _BINARY_OPERATION_
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ _INTOP_ *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (TYPE*)auxPrev;   cz = (TYPE*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) _TEST_ (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register TYPE *cur = (TYPE*)(input);
	TYPE *resBuf = (TYPE*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register TYPE *px = cur;
	register TYPE *cy, *py, *ny;
	register TYPE *pz = cur, *nz = cur;
	register TYPE *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (TYPE*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (TYPE*)auxCurr;
	py = cy = ny = (TYPE*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cy == _NOTHINGTOBEDONE_ ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (TYPE*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (TYPE*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	      if ( *cur == _NOTHINGTOBEDONE_ ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (TYPE*)auxCurr;
	  py = cy = ny = (TYPE*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cy == _NOTHINGTOBEDONE_ ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (TYPE*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if _BINARY_OPERATION_
	    if ( *res == _NOTHINGTOBEDONE_ ) continue;
#endif
	    if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) _TEST_ (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (TYPE*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (TYPE*)auxCurr;
	py = cy = ny = (TYPE*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cy == _NOTHINGTOBEDONE_ ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (TYPE*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) _TEST_ (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register TYPE *cur = (TYPE*)(input);
	TYPE *resBuf = (TYPE*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register TYPE *px = cur;
	register TYPE *ppy = cur, *nny = cur;
	register TYPE *cy, *py, *ny;
#if _BINARY_OPERATION_
	register int *ic, *in, *ip;
#else
	register TYPE *cz, *pz, *nz;
#endif
	register TYPE *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (TYPE*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (TYPE*)auxCurr;
	py = cy = ny = (TYPE*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cy == _NOTHINGTOBEDONE_ ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (TYPE*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) _TEST_ (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *res == _NOTHINGTOBEDONE_ ) continue;
#endif
	  if ( (*nny) _TEST_ (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) _TEST_ (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) _TEST_ (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (TYPE*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cur == _NOTHINGTOBEDONE_ ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (TYPE*)auxNext;
	py = cy = ny = (TYPE*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *cy == _NOTHINGTOBEDONE_ ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (TYPE*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) _TEST_ (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if _BINARY_OPERATION_
	  if ( *res == _NOTHINGTOBEDONE_ ) continue;
#endif
	  if ( (*nny) _TEST_ (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) _TEST_ (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) _TEST_ (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if _BINARY_OPERATION_
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ _INTOP_= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (TYPE*)auxCurr;   nz = (TYPE*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) _TEST_ (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (TYPE*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if _BINARY_OPERATION_
	      if ( *cur == _NOTHINGTOBEDONE_ ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) _TEST_ (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) _TEST_ (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) _TEST_ (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (TYPE*)auxNext;
	  py = cy = ny = (TYPE*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *cy == _NOTHINGTOBEDONE_ ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) _TEST_ (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) _TEST_ (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) _TEST_ (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (TYPE*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) _TEST_ (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if _BINARY_OPERATION_
	    if ( *res == _NOTHINGTOBEDONE_ ) continue;
#endif
	    if ( (*nny) _TEST_ (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) _TEST_ (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) _TEST_ (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if _BINARY_OPERATION_
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ _INTOP_= *in++ _INTOP_ *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (TYPE*)auxCurr;   nz = (TYPE*)aux4Next;
	  pz = (TYPE*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) _TEST_ (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) _TEST_ (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if _BINARY_OPERATION_
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ _INTOP_= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (TYPE*)auxCurr;   pz = (TYPE*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) _TEST_ (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

